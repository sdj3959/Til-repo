## 1026 Java 기초 복습 (3/4): 클래스 심화와 예외 처리

---

### ✅ 1. 생성자 (Constructor)

*   **생성자**는 `new` 키워드를 통해 객체가 생성될 때, 해당 객체를 **초기화**하기 위해 호출되는 특별한 종류의 메서드입니다.

*   **주요 규칙**:
    1.  생성자의 이름은 **클래스의 이름과 반드시 동일**해야 합니다.
    2.  생성자는 **반환 타입(return type)을 가지지 않습니다**.
    3.  클래스에 생성자를 하나도 정의하지 않으면, 컴파일러가 매개변수가 없는 **기본 생성자(Default Constructor)**를 자동으로 추가해줍니다.

*   **`this` 키워드**:
    *   **`this.멤버변수`**: 생성자의 매개변수 이름과 멤버 변수의 이름이 같을 때, 둘을 구분하기 위해 **현재 객체 자신**을 가리키는 `this`를 사용합니다.
    *   **`this()`**: 같은 클래스 내의 **다른 생성자를 호출**할 때 사용합니다. 반드시 생성자의 첫 줄에서만 호출할 수 있습니다.

    ```java
    public class Member {
        private String name;
        private int age;

        // 기본 생성자
        public Member() {
            this("Guest", 0); // 아래의 다른 생성자를 호출
        }

        // 매개변수가 있는 생성자
        public Member(String name, int age) {
            this.name = name; // this.name은 멤버 변수, name은 매개변수
            this.age = age;
        }
    }
    ```

---

### ✅ 2. 메서드 오버로딩 (Method Overloading)

*   **오버로딩**이란 **하나의 클래스 내**에서 **같은 이름의 메서드를 여러 개 정의**하는 것입니다.
*   **성립 조건**: 메서드 이름은 같지만, **매개변수의 개수나 타입**이 달라야 합니다. (반환 타입은 오버로딩 조건과 무관합니다.)
*   **장점**: 동일한 기능을 수행하지만, 다양한 종류의 매개변수를 처리해야 할 때, 메서드 이름을 하나로 통일하여 코드의 가독성과 일관성을 높일 수 있습니다.

    ```java
    public class Calculator {
        int add(int a, int b) {
            return a + b;
        }

        // 매개변수의 개수가 다름 -> 오버로딩 O
        int add(int a, int b, int c) {
            return a + b + c;
        }

        // 매개변수의 타입이 다름 -> 오버로딩 O
        double add(double a, double b) {
            return a + b;
        }
    }
    ```
*   **오버라이딩 vs 오버로딩**:
    *   **오버라이딩**: **상속 관계**에서 부모의 메서드를 자식이 **재정의**하는 것.
    *   **오버로딩**: **하나의 클래스** 내에서 이름이 같고 매개변수가 다른 메서드를 **여러 개 정의**하는 것.

---

### ✅ 3. static 멤버와 final 키워드

#### ➕ `static` (정적) 멤버

*   `static` 키워드가 붙은 멤버(변수, 메서드)는 **클래스에 소속**되며, 객체(인스턴스)를 생성하지 않고도 **`클래스명.멤버명`** 형태로 직접 접근할 수 있습니다.
*   **특징**:
    *   메모리의 **정적(static) 영역**에 단 하나만 생성되어, 해당 클래스의 **모든 객체가 공유**합니다.
    *   **`static` 메서드** 내에서는 `static` 멤버에만 접근할 수 있습니다. (객체가 생성되기 전에도 호출될 수 있으므로, 인스턴스 멤버에는 접근 불가)
*   **사용 사례**: 모든 객체가 공통으로 사용하는 값(e.g., `Math.PI`), 유틸리티성 메서드(e.g., `Math.random()`) 등에 사용됩니다.

    ```java
    class Counter {
        static int count = 0; // 정적 변수
        Counter() {
            count++; // 객체가 생성될 때마다 모든 객체가 공유하는 count가 증가
        }
    }
    ```

#### ➕ `final` 키워드

*   `final`은 "최종적인"이라는 의미로, 어디에 붙느냐에 따라 다른 역할을 합니다.

| 대상 | 설명 |
| :--- | :--- |
| **`final` 변수** | **상수(Constant)**가 되어, 최초 한 번만 초기화할 수 있고 이후에는 값을 변경할 수 없습니다. |
| **`final` 메서드** | **오버라이딩(재정의)을 금지**합니다. |
| **`final` 클래스** | **상속을 금지**합니다. (e.g., `String`, `Integer` 클래스) |

---

### ✅ 4. 예외 처리 (Exception Handling)

*   **예외(Exception)**란 프로그램 실행 중 발생하는 **예상치 못한 오류**를 의미합니다. 예외 처리는 이러한 오류가 발생했을 때 프로그램이 비정상적으로 종료되는 것을 막고, 정상적인 실행 흐름을 유지하도록 만드는 중요한 메커니즘입니다.

#### ➕ `try-catch-finally` 구문

*   **`try`**: 예외가 발생할 가능성이 있는 코드를 감쌉니다.
*   **`catch`**: `try` 블록에서 특정 종류의 예외가 발생했을 때, 이를 잡아(catch) 처리하는 코드를 작성합니다.
*   **`finally`**: 예외 발생 여부와 **상관없이 항상 실행**되어야 하는 코드를 작성합니다. (e.g., 사용했던 리소스(파일, DB 커넥션)를 닫는 코드)

    ```java
    try {
        // 예외 발생 가능성이 있는 코드
        int result = 10 / 0; // ArithmeticException 발생
    } catch (ArithmeticException e) {
        // 예외 처리 코드
        System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
    } catch (Exception e) {
        // 다른 모든 예외를 처리 (보통 가장 마지막에 위치)
        System.out.println("알 수 없는 오류 발생");
    } finally {
        // 항상 실행되는 코드
        System.out.println("예외 처리 종료");
    }
    ```

#### ➕ `throws` 키워드

*   메서드 선언부에서 `throws` 키워드를 사용하면, 해당 메서드 내에서 발생할 수 있는 예외를 **직접 처리하지 않고**, 이 메서드를 **호출한 쪽으로 예외 처리를 떠넘길(위임할)** 수 있습니다.

---

### 📌 요약

*   **생성자**는 객체 생성 시 **초기화**를 담당하며, **`this`** 키워드를 통해 멤버 변수를 구분하거나 다른 생성자를 호출할 수 있습니다.
*   **메서드 오버로딩**은 하나의 클래스 내에서 **이름이 같고 매개변수가 다른** 메서드를 여러 개 정의하여 코드의 일관성을 높입니다.
*   **`static`** 멤버는 클래스에 소속되어 **모든 객체가 공유**하며, **`final`** 키워드는 변수, 메서드, 클래스가 **변경되거나 확장되는 것을 방지**합니다.
*   **예외 처리 (`try-catch-finally`)**는 프로그램 실행 중 발생하는 오류에 대비하여, 시스템의 비정상적인 종료를 막고 안정성을 높이는 필수적인 방법입니다.