## 1126 Spring Boot 실전: AWS 배포와 OAuth2 심화

---

### ✅ 1. AWS EC2에 Spring Boot 애플리케이션 배포하기

*   개발이 완료된 Spring Boot 애플리케이션을 클라우드 서버(AWS EC2)에 배포하여, 인터넷을 통해 누구나 접근할 수 있도록 만드는 과정입니다.

#### ➕ 배포 절차 요약

1.  **EC2 인스턴스 준비**:
    *   AWS에서 EC2 인스턴스(가상 서버)를 생성합니다.
    *   Java(JDK), Git 등 애플리케이션 실행에 필요한 런타임을 설치합니다.
    *   **보안 그룹**을 설정하여, 필요한 포트(SSH: 22, HTTP: 80, HTTPS: 443)에 대한 접근을 허용합니다.

2.  **애플리케이션 빌드 및 전송**:
    *   로컬에서 프로젝트를 빌드하여 실행 가능한 **JAR 파일**을 생성합니다 (`./gradlew build`).
    *   생성된 JAR 파일을 `scp`나 `FileZilla`와 같은 도구를 사용하여 EC2 인스턴스로 전송합니다.

3.  **환경 변수 설정 및 실행**:
    *   데이터베이스 비밀번호, JWT 시크릿 키 등 민감한 정보는 코드에 하드코딩하는 대신, EC2 서버의 **환경 변수**로 설정합니다.
    *   `nohup` 명령어와 함께 JAR 파일을 실행하여, SSH 접속이 끊어져도 애플리케이션이 계속 백그라운드에서 동작하도록 합니다.
        ```bash
        # nohup: 터미널 세션이 종료되어도 프로세스를 계속 실행
        # > app.log 2>&1: 표준 출력과 표준 에러를 app.log 파일로 리다이렉션
        # &: 백그라운드에서 실행
        nohup java -jar -Dspring.profiles.active=prod my-app.jar > app.log 2>&1 &
        ```

4.  **Nginx를 이용한 리버스 프록시(Reverse Proxy) 설정**:
    *   **문제점**: Spring Boot 내장 Tomcat을 80번 포트(HTTP 기본 포트)로 직접 실행하는 것은 보안상 권장되지 않으며, 여러 애플리케이션을 함께 서비스하거나 정적 파일을 처리하는 데 비효율적입니다.
    *   **리버스 프록시**: **Nginx**와 같은 웹 서버를 애플리케이션 서버 앞에 두어, 모든 외부 요청을 Nginx가 먼저 받도록 하는 구조입니다.
    *   **Nginx의 역할**:
        *   `mydomain.com:80`으로 들어온 요청을 내부적으로 `localhost:8080`에서 실행 중인 Spring Boot 애플리케이션으로 **전달(proxy_pass)**합니다.
        *   로드 밸런싱, SSL/TLS 처리(HTTPS), 정적 파일 서빙 등의 역할을 수행할 수 있습니다.

---

### ✅ 2. OAuth2 소셜 로그인 심화

*   Spring Security의 `oauth2-client`를 사용하여, 사용자가 카카오, 구글 등 소셜 계정으로 우리 서비스에 간편하게 로그인하는 기능을 구현하는 심화 과정입니다.

#### ➕ OAuth2 로그인 처리 흐름 (Spring Security 내부)

1.  **[사용자]**: "카카오로 로그인" 버튼 클릭. 프론트엔드는 백엔드가 제공하는 OAuth2 인증 URL(`.../oauth2/authorization/kakao`)로 리다이렉트.

2.  **[Spring Security]**: 요청을 가로채, `application.yml`에 설정된 정보를 바탕으로 사용자를 카카오 로그인 페이지로 리다이렉트시킵니다.

3.  **[사용자 ↔ 카카오]**: 사용자가 카카오 계정으로 로그인하고 정보 제공에 동의하면, 카카오는 Spring 서버의 **리다이렉트 URI**로 **인가 코드(Authorization Code)**와 함께 사용자를 돌려보냅니다.

4.  **[Spring Security]**: 인가 코드를 받아, 카카오 서버와 통신하여 **액세스 토큰(Access Token)**을 발급받습니다.

5.  **[Spring Security]**: 발급받은 액세스 토큰을 사용하여 카카오 리소스 서버에 **사용자 정보**를 요청합니다.

6.  **[CustomOAuth2UserService] (개발자 구현 영역)**:
    *   Spring Security는 받아온 사용자 정보를 `CustomOAuth2UserService`에게 전달합니다.
    *   이 서비스는 전달받은 소셜 정보(이메일 등)를 바탕으로, 우리 서비스의 **데이터베이스를 확인**합니다.
        *   **기존 회원**: 회원 정보를 최신 상태로 업데이트합니다.
        *   **신규 회원**: 받아온 정보로 새로운 사용자 레코드를 생성하여 **자동으로 회원가입**시킵니다.
    *   마지막으로, Spring Security가 인증을 처리할 수 있도록 사용자 정보를 담은 `Principal` 객체를 반환합니다.

7.  **[OAuth2SuccessHandler] (개발자 구현 영역)**:
    *   인증이 성공적으로 완료되면, 이 핸들러가 호출됩니다.
    *   여기서 우리 서비스만의 **독자적인 인증 토큰(JWT)**을 생성합니다.
    *   생성된 JWT를 **URL 파라미터**나 **`Http-Only` 쿠키**에 담아, 프론트엔드로 리다이렉트시키면서 전달합니다.

8.  **[프론트엔드]**: 리다이렉트된 URL에서 JWT를 파싱하여 저장하고, 로그인 상태를 유지합니다.

*   **핵심**: 개발자는 주로 **`CustomOAuth2UserService`** (사용자 정보 처리 및 회원가입)와 **`OAuth2SuccessHandler`** (로그인 성공 후 JWT 발급) 두 부분을 커스터마이징하여 비즈니스 로직을 구현하게 됩니다.

---

### 📌 요약

*   Spring Boot 애플리케이션을 EC2에 배포할 때는, **환경 변수**로 설정을 주입하고 **`nohup`**을 사용하여 백그라운드로 실행합니다.
*   **Nginx**를 **리버스 프록시**로 사용하여, 외부 요청(80/443 포트)을 내부 애플리케이션(8080 포트)으로 안전하고 효율적으로 전달하는 구조가 권장됩니다.
*   **Spring Security OAuth2**는 소셜 로그인 인증의 복잡한 흐름을 대부분 자동화해줍니다.
*   개발자는 주로 **`CustomOAuth2UserService`**에서 **사용자 정보를 우리 DB와 동기화(회원가입/업데이트)**하는 로직과, **`OAuth2SuccessHandler`**에서 인증 성공 후 **우리 서비스의 JWT를 발급**하는 로직을 구현하는 데 집중하게 됩니다.