## 1101 Java 중급으로의 도약: 네트워킹, 날짜/시간 API, 리플렉션

---

### ✅ 1. Java 네트워킹 (Networking)

*   Java 네트워킹은 서로 다른 컴퓨터(프로세스) 간에 데이터를 교환할 수 있도록 지원하는 기능입니다. 모든 네트워크 통신은 **소켓(Socket)**을 기반으로 합니다.

#### ➕ 네트워킹의 기본 요소

*   **IP 주소**: 네트워크상에서 컴퓨터를 식별하는 고유한 주소. (e.g., `127.0.0.1` - 로컬 컴퓨터)
*   **포트 (Port)**: 컴퓨터 내에서 특정 프로세스(애플리케이션)를 식별하는 번호. (0 ~ 65535)
*   **소켓 (Socket)**: **IP 주소와 포트 번호의 조합**으로, 실제 데이터 통신이 이루어지는 **연결의 끝점(Endpoint)**입니다.

#### ➕ Java의 주요 네트워킹 클래스

1.  **`ServerSocket` (서버용)**:
    *   클라이언트의 연결 요청을 **기다리는** 역할을 합니다.
    *   `accept()` 메서드를 통해 클라이언트의 연결 요청을 수락하고, 실제 통신을 위한 **`Socket` 객체를 생성**하여 반환합니다.

2.  **`Socket` (클라이언트용 및 통신용)**:
    *   클라이언트 측에서는 서버의 IP와 포트로 **연결을 요청**하기 위해 사용됩니다.
    *   서버 측에서는 `ServerSocket`이 생성해준 객체로, 연결된 클라이언트와 **1:1로 데이터를 주고받기 위해** 사용됩니다.
    *   `getInputStream()`과 `getOutputStream()`을 통해 데이터를 읽고 쓰는 스트림을 얻을 수 있습니다.

    ```java
    // 간단한 서버 예시
    try (ServerSocket serverSocket = new ServerSocket(9090)) {
        System.out.println("서버가 연결을 기다립니다...");
        Socket clientSocket = serverSocket.accept(); // 클라이언트 연결 대기
        System.out.println("클라이언트가 연결되었습니다.");
        // ... clientSocket을 이용한 데이터 통신 ...
    } catch (IOException e) {
        e.printStackTrace();
    }
    ```

---

### ✅ 2. 새로운 날짜와 시간 API (`java.time` 패키지)

*   Java 8 이전의 `Date`와 `Calendar` 클래스는 가변성(mutable), 복잡한 API, 월(month) 계산 오류(0부터 시작) 등 여러 문제점을 가지고 있었습니다. Java 8에서 도입된 `java.time` 패키지는 이러한 문제들을 해결한 **새로운 표준**입니다.

#### ➕ `java.time` 패키지의 핵심 특징

*   **불변성 (Immutable)**: 모든 날짜/시간 객체는 한 번 생성되면 변경할 수 없어 **스레드에 안전(Thread-safe)**합니다. 날짜를 변경하면 항상 새로운 객체가 반환됩니다.
*   **명확한 API**: `plusDays()`, `minusHours()` 등 직관적인 메서드 이름을 제공합니다.
*   **개념 분리**: 날짜(`LocalDate`), 시간(`LocalTime`), 날짜와 시간(`LocalDateTime`), 시간대(`ZonedDateTime`) 등 역할이 명확하게 분리되어 있습니다.

#### ➕ 주요 클래스

| 클래스 | 설명 | 예시 |
| :--- | :--- | :--- |
| **`LocalDate`** | 날짜 정보만 표현 (e.g., `2025-11-01`) | `LocalDate.now()`, `LocalDate.of(2025, 11, 1)` |
| **`LocalTime`** | 시간 정보만 표현 (e.g., `10:30:55`) | `LocalTime.now()`, `LocalTime.of(10, 30)` |
| **`LocalDateTime`** | 날짜와 시간을 함께 표현 (e.g., `2025-11-01T10:30:55`) | `LocalDateTime.now()` |
| **`ZonedDateTime`** | `LocalDateTime`에 **시간대(Timezone)** 정보를 포함 | `ZonedDateTime.now(ZoneId.of("Asia/Seoul"))` |
| **`Period`** | **날짜** 간의 간격 (년, 월, 일) | `Period.between(date1, date2)` |
| **`Duration`** | **시간** 간의 간격 (시, 분, 초, 나노초) | `Duration.between(time1, time2)` |
| **`DateTimeFormatter`** | 날짜/시간 객체를 원하는 형식의 **문자열로 포맷팅**하거나, 문자열을 파싱 | `formatter.format(now)`, `LocalDate.parse(str, formatter)` |

---

### ✅ 3. 어노테이션(Annotation)과 리플렉션(Reflection)

*   이들은 프레임워크(Spring, JPA 등)의 동작 원리를 이해하는 데 필수적인 고급 개념입니다.

#### ➕ 어노테이션 (Annotation)

*   **어노테이션(`@`)**은 **"메타데이터(Metadata)"**입니다. 즉, 코드 자체의 일부는 아니지만, 코드에 대한 **부가적인 정보**를 제공하는 역할을 합니다.
*   **역할**:
    1.  **컴파일러에게 정보 제공**: `@Override`, `@Deprecated` 등 컴파일러가 문법 체크를 하도록 돕습니다.
    2.  **빌드 시 코드 자동 생성**: 롬복(`@Getter`, `@Setter`)과 같이 빌드 타임에 코드를 생성합니다.
    3.  **런타임 시 정보 제공**: `@Controller`, `@Autowired` 등 프로그램 실행 중에 **리플렉션**을 통해 특정 로직을 수행하도록 정보를 제공합니다. (프레임워크의 핵심)

#### ➕ 리플렉션 (Reflection)

*   **리플렉션**은 프로그램이 **실행 중에(Runtime)** 자기 자신(클래스, 메서드, 필드 등)의 구조를 **검사하고, 생성하고, 수정**할 수 있는 강력한 기능입니다.
*   **동작 원리**:
    1.  Spring 컨테이너는 시작될 때, `@Component`와 같은 어노테이션이 붙은 클래스들을 찾습니다.
    2.  **리플렉션**을 사용하여 해당 클래스의 정보를 읽어와 객체(Bean)를 생성합니다.
    3.  `@Autowired`가 붙은 필드를 찾으면, **리플렉션**을 사용하여 해당 필드에 미리 만들어 둔 다른 Bean 객체를 **주입(Injection)**합니다.

*   **결론**: **어노테이션**은 "표지판"을 붙이는 행위이고, **리플렉션**은 런타임에 그 "표지판"을 읽고 특별한 동작을 수행하는 기술입니다. Spring의 **DI(의존성 주입)**와 **AOP(관점 지향 프로그래밍)**는 모두 이 리플렉션 기술을 기반으로 동작합니다.

---

### 📌 요약

*   Java의 **네트워킹**은 **소켓(IP+Port)**을 기반으로 하며, 서버는 **`ServerSocket`**으로 연결을 기다리고, 실제 통신은 **`Socket`**을 통해 이루어집니다.
*   날짜와 시간 처리는 반드시 Java 8에서 도입된 **`java.time`** 패키지(e.g., `LocalDateTime`)를 사용해야 합니다. 이 API는 **불변성**을 보장하여 안전하고 직관적입니다.
*   **어노테이션**은 코드에 대한 **메타데이터(부가 정보)**를 제공하며, **리플렉션**은 런타임에 이 어노테이션 정보를 읽어 **동적인 로직을 수행**하는 기술입니다. 이는 Spring과 같은 현대적인 프레임워크의 핵심 동작 원리입니다.