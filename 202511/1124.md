## 1124 Spring Security: 인증(Authentication)과 인가(Authorization)

---

### ✅ 1. Spring Security란?

*   **Spring Security**는 Spring 기반의 애플리케이션에서 **보안(인증과 인가)**을 쉽고 강력하게 구현할 수 있도록 지원하는 프레임워크입니다.
*   보안과 관련된 거의 모든 표준적인 기능(폼 로그인, 소셜 로그인, JWT, CORS, CSRF 방어 등)을 제공하며, 서블릿 필터(Filter) 체인을 기반으로 동작합니다.

---

### ✅ 2. 보안의 두 기둥: 인증(Authentication) vs 인가(Authorization)

*   Spring Security를 이해하기 위해서는 이 두 가지 개념을 명확히 구분하는 것이 가장 중요합니다.

| 구분 | 인증 (Authentication) | 인가 (Authorization) |
| :--- | :--- | :--- |
| **질문** | **"당신은 누구입니까?"** (Who are you?) | **"당신은 무엇을 할 수 있습니까?"** (What can you do?) |
| **목적** | 사용자의 **신원을 확인**하는 과정 | 신원이 확인된 사용자가 특정 리소스에 **접근할 권한이 있는지** 확인하는 과정 |
| **결과** | 인증 성공 또는 실패 | 접근 허용 또는 거부 |
| **예시** | • 아이디/비밀번호로 로그인<br>• 소셜 로그인<br>• 지문 인식 | • 관리자(ADMIN)만 접근 가능한 페이지<br>• 사용자(USER)는 자신의 게시글만 수정 가능 |
| **순서** | **항상 인가보다 먼저** 수행됨 | 반드시 인증이 성공한 후에 수행됨 |

---

### ✅ 3. Spring Security의 핵심 아키텍처

*   Spring Security는 **서블릿 필터 체인(Servlet Filter Chain)**을 기반으로 동작합니다. 클라이언트의 요청이 `DispatcherServlet`에 도달하기 전에, 여러 개의 보안 필터들이 체인처럼 연결되어 순차적으로 요청을 검사하고 처리합니다.

#### ➕ 주요 컴포넌트와 흐름

1.  **`SecurityFilterChain`**:
    *   `DelegatingFilterProxy`를 통해 들어온 요청을 처리하는 필터들의 체인입니다.
    *   개발자는 `SecurityFilterChain`을 Bean으로 등록하여, 애플리케이션의 보안 규칙(URL별 접근 제어, 로그인 방식 등)을 **Java 설정 코드**로 정의합니다.

2.  **`AuthenticationManager`**:
    *   **인증(Authentication)**을 총괄하는 관리자입니다.
    *   로그인 요청이 들어오면, `AuthenticationManager`는 적절한 `AuthenticationProvider`에게 인증 처리를 위임합니다.

3.  **`AuthenticationProvider`**:
    *   실제로 사용자가 제출한 정보(e.g., 아이디/비밀번호)와 DB에 저장된 정보를 비교하여 **인증을 수행**하는 주체입니다.
    *   인증에 성공하면, 사용자 정보와 권한을 담은 **`Authentication` 객체**를 생성하여 반환합니다.

4.  **`SecurityContextHolder` & `SecurityContext`**:
    *   인증이 성공적으로 완료되면, 생성된 `Authentication` 객체는 **`SecurityContext`**에 저장되고, 이 `SecurityContext`는 **`SecurityContextHolder`**에 보관됩니다.
    *   `SecurityContextHolder`는 `ThreadLocal`을 사용하여 현재 스레드 내에서 `Authentication` 객체를 공유합니다. 이를 통해 애플리케이션의 어느 곳에서든 `@AuthenticationPrincipal`과 같은 어노테이션으로 현재 로그인된 사용자 정보에 쉽게 접근할 수 있습니다.

5.  **`AccessDecisionManager`**:
    *   **인가(Authorization)**를 총괄하는 관리자입니다.
    *   인증된 사용자가 특정 URL(리소스)에 접근을 시도할 때, `SecurityContextHolder`에서 `Authentication` 객체를 꺼내 사용자의 권한을 확인하고, 해당 리소스에 접근할 수 있는지 여부를 결정합니다.

---

### ✅ 4. Java 기반의 보안 설정 (`SecurityFilterChain`)

*   과거에는 XML로 보안 설정을 했지만, 현재는 `WebSecurityConfigurerAdapter`를 상속받거나(Deprecated), **`SecurityFilterChain`을 Bean으로 직접 등록**하는 Java 기반의 설정이 표준입니다.

```java
@Configuration
@EnableWebSecurity // Spring Security 활성화
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            // 1. 인가(Authorization) 규칙 설정
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/admin/**").hasRole("ADMIN") // /admin/** 경로는 ADMIN 역할만 접근 가능
                .requestMatchers("/my-page").hasAnyRole("USER", "ADMIN") // /my-page는 USER 또는 ADMIN 역할
                .requestMatchers("/", "/login", "/signup").permitAll() // /, /login, /signup 경로는 모두 접근 허용
                .anyRequest().authenticated() // 그 외 모든 요청은 인증된 사용자만 접근 가능
            )
            
            // 2. 폼 로그인(Form Login) 설정
            .formLogin(form -> form
                .loginPage("/login") // 커스텀 로그인 페이지 경로
                .defaultSuccessUrl("/dashboard", true) // 로그인 성공 시 이동할 경로
                .permitAll()
            )
            
            // 3. 로그아웃(Logout) 설정
            .logout(logout -> logout
                .logoutUrl("/logout")
                .logoutSuccessUrl("/")
            )
            
            // 4. CSRF, CORS 등 기타 보안 설정
            .csrf(AbstractHttpConfigurer::disable); // 개발 편의를 위해 CSRF 비활성화 (운영 시 주의)

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        // 비밀번호 암호화를 위한 PasswordEncoder Bean 등록
        return new BCryptPasswordEncoder();
    }
}
```

---

### 📌 요약

*   **인증(Authentication)**은 **"신원 확인"**의 과정이고, **인가(Authorization)**는 **"권한 부여"**의 과정입니다.
*   Spring Security는 **서블릿 필터 체인**을 기반으로 동작하며, 요청이 컨트롤러에 도달하기 전에 다양한 보안 검사를 수행합니다.
*   **`AuthenticationManager`**가 인증을, **`AccessDecisionManager`**가 인가를 총괄하며, 인증된 사용자 정보는 **`SecurityContextHolder`**에 저장되어 애플리케이션 전반에서 공유됩니다.
*   현대적인 Spring Security 설정은 **`SecurityFilterChain`을 Bean으로 등록**하는 Java 기반의 코드로 이루어지며, 이를 통해 URL별 접근 제어, 로그인/로그아웃 방식 등을 매우 유연하고 상세하게 정의할 수 있습니다.