## 1109 Spring Boot: Docker 컨테이너화와 CI/CD 자동 배포

---

### ✅ 1. Docker를 이용한 애플리케이션 컨테이너화

*   **컨테이너화(Containerization)**란 애플리케이션과 그 실행에 필요한 모든 환경(JDK, 라이브러리, 설정 파일 등)을 **"컨테이너"**라는 격리된 표준 단위로 패키징하는 기술입니다. Docker는 이를 위한 가장 대표적인 플랫폼입니다.

*   **핵심 장점**: "제 컴퓨터에서는 되는데, 서버에서는 안 돼요" 문제를 근본적으로 해결합니다. 컨테이너는 OS나 환경에 구애받지 않고 어디서든 동일하게 동작하는 것을 보장합니다.

#### ➕ Spring Boot 애플리케이션의 Dockerizing 절차

1.  **`Dockerfile` 작성**:
    *   `Dockerfile`은 나만의 커스텀 **Docker 이미지를 만들기 위한 설명서(Recipe)**입니다.
    *   이 텍스트 파일에 베이스 이미지 선택, 파일 복사, 실행 명령어 등을 순서대로 정의합니다.

    ```dockerfile
    # 1. 베이스 이미지: Java 17 환경이 설치된 경량 리눅스
    FROM openjdk:17-jdk-slim

    # 2. 작업 디렉토리 설정
    WORKDIR /app

    # 3. 빌드된 JAR 파일을 컨테이너 안으로 복사
    COPY build/libs/*.jar app.jar

    # 4. 컨테이너가 시작될 때 실행할 명령어
    CMD ["java", "-jar", "app.jar"]
    ```

2.  **Docker 이미지 빌드**:
    *   `Dockerfile`을 기반으로 `docker build` 명령어를 실행하여 애플리케이션의 스냅샷인 **Docker 이미지**를 생성합니다.
    *   `docker build -t my-spring-app:0.0.1 .`

3.  **Docker 컨테이너 실행**:
    *   생성된 이미지를 `docker run` 명령어로 실행하여, 실제 동작하는 **컨테이너**를 띄웁니다.
    *   `docker run -p 8080:8080 my-spring-app:0.0.1`

---

### ✅ 2. Docker Compose: 멀티 컨테이너 애플리케이션 관리

*   **문제점**: 실제 애플리케이션은 웹 서버, 데이터베이스 등 여러 개의 컨테이너가 함께 동작해야 합니다. 이들을 `docker run` 명령어로 하나씩 관리하는 것은 매우 번거롭습니다.

*   **Docker Compose**: **여러 개의 컨테이너**로 구성된 애플리케이션을 **하나의 YAML 파일**(`docker-compose.yml`)로 정의하고, 단 하나의 명령어로 전체 서비스를 관리할 수 있게 해주는 도구입니다.

*   **`docker-compose.yml`의 역할**:
    *   **서비스 정의**: 실행할 컨테이너들(e.g., `spring-app`, `database`)을 `services` 아래에 정의합니다.
    *   **네트워크 연결**: 컨테이너들이 서로 통신할 수 있는 가상 네트워크를 정의합니다. 컨테이너들은 IP 주소가 아닌 **서비스 이름**(e.g., `database`)으로 서로를 참조할 수 있습니다.
    *   **환경 변수 주입**: 데이터베이스 비밀번호와 같은 민감한 정보를 `environment` 키를 통해 안전하게 주입합니다.
    *   **볼륨 마운트**: 데이터베이스 파일과 같이 영속적으로 보존해야 할 데이터를 컨테이너 외부(호스트)에 저장하도록 `volumes`를 설정합니다.

---

### ✅ 3. CI/CD (지속적 통합/배포) 파이프라인 구축

*   **CI/CD**는 애플리케이션 개발부터 배포까지의 전체 과정을 **자동화**하여, 개발자가 코드 작성에만 집중하고, 빠르고 안정적으로 서비스를 제공할 수 있도록 하는 개발 문화이자 방법론입니다.

*   **CI (Continuous Integration, 지속적 통합)**: 개발자가 코드를 Git 리포지토리에 푸시(Push)하면, **자동으로 빌드(Build)되고 테스트(Test)되는** 과정입니다.
*   **CD (Continuous Deployment, 지속적 배포)**: CI 단계가 성공적으로 완료되면, 그 결과물이 **자동으로 실제 운영 서버에 배포(Deploy)되는** 과정입니다.

---

### ✅ 4. GitHub Actions를 이용한 자동 배포 파이프라인

*   **GitHub Actions**는 GitHub에 내장된 CI/CD 도구로, 별도의 서버 없이 `.yml` 설정 파일만으로 파이프라인을 쉽게 구축할 수 있습니다.

#### ➕ Spring Boot 애플리케이션의 자동 배포 파이프라인 흐름

1.  **트리거 (Trigger)**: 개발자가 `main` 브랜치에 코드를 **푸시(Push)**하면 파이프라인이 자동으로 시작됩니다.

2.  **[CI] 빌드 및 이미지 생성 (GitHub Actions 서버에서 실행)**:
    a. JDK를 설정하고, `./gradlew build`로 Spring Boot 프로젝트를 빌드하여 **JAR 파일을 생성**합니다.
    b. `Dockerfile`을 사용하여 **Docker 이미지를 빌드**합니다.
    c. 빌드된 이미지를 **Docker Hub**와 같은 이미지 레지스트리에 **푸시(Push)**합니다.

3.  **[CD] 서버 배포 (AWS EC2 서버에서 실행)**:
    a. GitHub Actions가 **SSH를 통해 AWS EC2 서버에 원격으로 접속**합니다.
    b. EC2 서버에서 다음 명령어들을 순차적으로 실행합니다.
        i. **최신 이미지 풀(Pull)**: Docker Hub에서 방금 푸시한 최신 버전의 이미지를 내려받습니다.
        ii. **기존 컨테이너 중지/제거**: 이전에 실행 중이던 구버전 컨테이너를 중지하고 제거합니다. (무중단 배포를 위해서는 블루/그린, 카나리 등의 고급 전략 필요)
        iii. **새 컨테이너 실행**: 최신 이미지를 기반으로 **새로운 컨테이너를 실행**하여 배포를 완료합니다.

*   **GitHub Secrets**: Docker Hub 비밀번호, AWS EC2 접속 SSH 키와 같은 민감한 정보는 GitHub 리포지토리의 **Secrets**에 안전하게 저장하고, 워크플로우 파일에서는 `${{ secrets.MY_SECRET }}` 형태로 참조하여 보안을 유지해야 합니다.

---

### 📌 요약

*   **Docker**는 Spring Boot 애플리케이션과 그 실행 환경을 **컨테이너**라는 표준 단위로 패키징하여 이식성을 높입니다.
*   **Docker Compose**는 웹 서버, 데이터베이스 등 **여러 컨테이너**로 구성된 애플리케이션 스택을 `docker-compose.yml` 파일 하나로 손쉽게 관리할 수 있게 해줍니다.
*   **CI/CD 파이프라인**은 코드 푸시부터 서버 배포까지의 전 과정을 **자동화**하는 현대적인 개발의 필수 요소입니다.
*   **GitHub Actions**를 사용하면, **[빌드 → 이미지 생성/푸시 → 서버 접속 → 컨테이너 재실행]**으로 이어지는 배포 파이프라인을 `.yml` 파일로 정의하여 간편하게 구축할 수 있습니다.