## 0216 스프링 MVC 동작 원리 복습

---

### ✅ 1. Spring MVC란?

*   **Spring MVC**는 Spring 프레임워크에서 제공하는 **웹(Web) 애플리케이션 개발 모듈**입니다. 웹 개발의 표준적인 디자인 패턴인 **MVC(Model-View-Controller) 패턴**을 기반으로, 웹 계층의 역할을 명확하게 분리하여 유연하고 확장성 있는 웹 애플리케이션을 만들 수 있도록 지원합니다.

*   **MVC 패턴의 역할 분리**:
    *   **Model**: 애플리케이션의 데이터와 비즈니스 로직을 포함. (Service, DTO, Entity 등)
    *   **View**: 사용자에게 보여지는 UI. (HTML, JSON 등)
    *   **Controller**: 사용자의 요청을 받아 Model과 View를 중개하는 역할.

---

### ✅ 2. Front Controller 패턴과 `DispatcherServlet`

*   Spring MVC는 **Front Controller 패턴**을 기반으로 설계되었습니다. 이는 모든 클라이언트의 요청을 **단 하나의 진입점**에서 먼저 받은 후, 요청에 맞는 컨트롤러로 작업을 위임하는 중앙 집중형 구조입니다.

*   **`DispatcherServlet`**:
    *   Spring MVC에서 **Front Controller**의 역할을 수행하는 핵심 서블릿(Servlet)입니다.
    *   클라이언트로부터 들어온 모든 HTTP 요청을 가장 먼저 받아, 요청 처리의 전 과정을 조율하고 지휘하는 **중앙 관제탑**과 같습니다.
    *   `DispatcherServlet` 덕분에 개발자는 서블릿을 직접 다루는 복잡함에서 벗어나, 컨트롤러 로직에만 집중할 수 있습니다.

---

### ✅ 3. Spring MVC의 요청 처리 흐름

*   클라이언트의 요청이 들어와서 응답이 나가기까지, `DispatcherServlet`은 여러 협력 컴포넌트들과 함께 다음과 같은 순서로 작업을 처리합니다.

    ![Spring MVC Flow](https://i.imgur.com/3yECb3v.png)

1.  **[요청]** 클라이언트가 URL을 요청하면 `DispatcherServlet`이 요청을 받습니다.

2.  **[핸들러 탐색] `HandlerMapping`**:
    *   `DispatcherServlet`은 `HandlerMapping`에게 "이 요청 URL(`.../users/1`)을 처리할 컨트롤러(핸들러)가 누구인지 찾아줘"라고 요청합니다.
    *   `HandlerMapping`은 `@RequestMapping`, `@GetMapping` 등의 어노테이션 정보를 기반으로, 요청을 처리할 적절한 컨트롤러 메서드를 찾아 `DispatcherServlet`에 반환합니다.

3.  **[핸들러 실행] `HandlerAdapter`**:
    *   `DispatcherServlet`은 찾아낸 컨트롤러를 직접 실행하지 않고, **`HandlerAdapter`**에게 컨트롤러 실행을 위임합니다.
    *   `HandlerAdapter`는 다양한 종류의 컨트롤러를 일관된 방식으로 실행할 수 있도록 도와주는 **"어댑터"** 역할을 합니다.
    *   `HandlerAdapter`는 컨트롤러 메서드를 실행하고, 그 결과를 `ModelAndView`라는 객체로 변환하여 `DispatcherServlet`에 반환합니다.

4.  **[컨트롤러 실행] `Controller`**:
    *   개발자가 작성한 컨트롤러 메서드가 실행됩니다.
    *   이 과정에서 서비스 계층을 호출하여 비즈니스 로직을 수행하고, 결과 데이터를 `Model` 객체에 담습니다.
    *   메서드의 반환 값으로 뷰(View)의 논리적 이름(String)이나, `@ResponseBody`가 붙은 경우 데이터 객체(DTO)를 반환합니다.

5.  **[뷰 탐색] `ViewResolver`**:
    *   (HTML 페이지를 반환하는 경우) `DispatcherServlet`은 컨트롤러로부터 받은 논리적인 뷰 이름(e.g., `"home"`)을 **`ViewResolver`**에게 전달합니다.
    *   `ViewResolver`는 이 논리적 이름을 실제 물리적인 뷰 파일(e.g., `/WEB-INF/views/home.jsp`)이나 템플릿(e.g., `templates/home.html`)으로 변환하는 **"주소록"** 역할을 합니다.

6.  **[렌더링 및 응답] `View`**:
    *   `DispatcherServlet`은 찾은 `View` 객체에 `Model` 데이터를 전달하여 최종 응답 화면을 렌더링하도록 요청합니다.
    *   `View`는 `Model` 데이터를 바탕으로 최종 응답(HTML)을 생성하여 클라이언트에게 반환합니다.
    *   (`@RestController`의 경우, `ViewResolver`와 `View` 단계를 건너뛰고, `HttpMessageConverter`가 반환된 객체를 JSON으로 변환하여 즉시 응답합니다.)

---

### ✅ 4. 주요 구성 요소 요약

| 컴포넌트 | 역할 | 비유 |
| :--- | :--- | :--- |
| **`DispatcherServlet`** | **중앙 관제탑** | 모든 요청을 받고 전체 흐름을 조율 |
| **`HandlerMapping`** | **요청-컨트롤러 매칭** | "이 주소는 어느 부서 담당인가요?"를 알려주는 안내 데스크 |
| **`HandlerAdapter`** | **컨트롤러 실행기** | 다양한 종류의 담당자(컨트롤러)를 동일한 방식으로 일하게 하는 비서 |
| **`Controller`** | **실제 업무 처리** | 요청을 받아 실제 비즈니스 로직을 수행하는 담당자 |
| **`ViewResolver`** | **뷰 주소록** | "결과 보고서 양식 어디있지?"를 알려주는 문서 관리자 |
| **`View`** | **최종 보고서 작성** | 데이터를 받아 최종 결과물(HTML, JSON)을 만드는 역할 |

---

### 📌 요약

*   Spring MVC는 모든 요청을 **`DispatcherServlet`**이라는 **Front Controller**가 먼저 받는 중앙 집중형 구조입니다.
*   `DispatcherServlet`은 직접 모든 일을 처리하는 대신, **`HandlerMapping`, `HandlerAdapter`, `ViewResolver`**와 같은 전문화된 컴포넌트들에게 **역할을 위임**하여 요청 처리의 전 과정을 조율합니다.
*   이러한 역할 분리와 위임 구조 덕분에, 각 컴포넌트의 기능이 명확해지고, 개발자는 비즈니스 로직을 담는 **`Controller`**의 구현에만 집중할 수 있어 생산성이 크게 향상됩니다.