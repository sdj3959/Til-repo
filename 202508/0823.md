## 0823 SQLD 1, 2과목 핵심 요약 정리

---

### ✅ 1과목: 데이터 모델링의 이해

데이터베이스의 **설계도**를 만드는 과정으로, 시스템의 안정성과 확장성을 결정하는 가장 중요한 단계입니다.

#### ➕ 1. 데이터 모델링의 핵심 요소 (ERD)

| 요소 | 설명 | 예시 |
| :--- | :--- | :--- |
| **엔터티 (Entity)** | 업무에서 관리해야 할 데이터의 집합 (명사) | 학생, 과목, 주문 (테이블) |
| **속성 (Attribute)** | 엔터티가 가지는 세부적인 정보 항목 | 학생의 학번, 이름, 학과 (컬럼) |
| **관계 (Relationship)** | 엔터티 간의 논리적 연관성 (동사) | 학생이 과목을 **수강한다**. |
| **식별자 (Identifier)** | 각 엔터티의 인스턴스를 유일하게 구분하는 속성 | 학번, 주문번호 (Primary Key) |

#### ➕ 2. 관계의 종류와 표현

*   **관계 차수 (Cardinality)**: 참여하는 인스턴스의 수
    *   **1:1**: `사원` - `좌석`
    *   **1:N**: `부서` - `사원` (가장 일반적)
    *   **M:N**: `학생` - `과목` → **관계형 DB에서 직접 표현 불가**. `수강`이라는 **관계 엔터티**를 만들어 1:N 관계로 해소해야 합니다.

*   **관계 선택성 (Optionality)**: 관계 참여가 필수인지 선택인지 여부
    *   **필수 (`|`)**: `주문`은 반드시 `고객`이 있어야 함.
    *   **선택 (`O`)**: `사원`은 `프로젝트`에 참여할 수도 있음.

#### ➕ 3. 식별자의 종류

*   **주 식별자 vs 보조 식별자**: 대표 식별자(PK)와 그 외 유일키(Unique)
*   **내부 식별자 vs 외부 식별자**: 스스로 생성된 식별자(PK)와 관계를 통해 받은 식별자(FK)
*   **식별 관계 vs 비식별 관계**:
    *   **식별 관계**: 부모의 PK를 자식이 **자신의 PK**로 사용. (부모 없이 자식 존재 불가)
    *   **비식별 관계**: 부모의 PK를 자식이 **일반 속성**으로 사용. (부모 없이도 자식 존재 가능)

#### ➕ 4. 정규화와 반정규화

*   **정규화 (Normalization)**: 데이터의 **중복을 최소화**하여 **무결성**을 확보하는 과정. (1NF, 2NF, 3NF)
    *   **1NF**: 속성의 원자성 확보.
    *   **2NF**: 부분 함수 종속 제거.
    *   **3NF**: 이행 함수 종속 제거.

*   **반정규화 (Denormalization)**: 정규화된 모델의 **조회 성능 향상**을 위해 의도적으로 중복을 허용하거나 테이블을 통합/분할하는 과정. **무결성과 성능의 Trade-off** 관계입니다.

---

### ✅ 2과목: SQL 기본 및 활용

데이터베이스를 **조작하고 활용**하는 언어. 문법 순서와 **논리적 실행 순서**의 차이를 이해하는 것이 가장 중요합니다.

#### ➕ 1. SELECT 문의 논리적 실행 순서

**`FROM` → `WHERE` → `GROUP BY` → `HAVING` → `SELECT` → `ORDER BY`**

1.  **`FROM`**: 테이블을 정의하고 JOIN을 처리합니다.
2.  **`WHERE`**: 개별 행을 필터링합니다. (집계 함수 불가)
3.  **`GROUP BY`**: 데이터를 그룹화합니다.
4.  **`HAVING`**: 그룹을 필터링합니다. (집계 함수 가능)
5.  **`SELECT`**: 최종 컬럼을 선택하고 계산합니다.
6.  **`ORDER BY`**: 결과를 정렬합니다.

#### ➕ 2. JOIN과 집합 연산자

*   **JOIN**: 두 개 이상의 테이블을 연결합니다.
    *   **`INNER JOIN`**: 일치하는 행만 반환 (교집합)
    *   **`OUTER JOIN`**: 일치하지 않아도 기준 테이블의 행은 반환 (`LEFT`, `RIGHT`, `FULL`)

*   **집합 연산자**: 두 `SELECT` 문의 결과를 합칩니다. (컬럼 수/타입 일치 필요)
    *   **`UNION`**: 중복을 제거한 합집합 (느림)
    *   **`UNION ALL`**: 중복을 포함한 합집합 (빠름)
    *   **`INTERSECT`**: 교집합
    *   **`MINUS` / `EXCEPT`**: 차집합

#### ➕ 3. 서브쿼리와 주요 함수

*   **서브쿼리 (Subquery)**: 다른 SQL 문에 포함된 `SELECT` 문.
    *   **스칼라 서브쿼리 (`SELECT` 절)**: 단일 값 반환.
    *   **인라인 뷰 (`FROM` 절)**: 가상 테이블로 사용.
    *   **중첩 서브쿼리 (`WHERE`, `HAVING` 절)**: 조건 비교에 사용.

*   **주요 함수**:
    *   **`CASE` 문**: SQL의 `IF-THEN-ELSE` 논리.
    *   **`NVL(A, B)` / `COALESCE(A, B, C...)`**: `NULL` 값을 다른 값으로 치환.
    *   **집계 함수**: `COUNT`, `SUM`, `AVG`, `MAX`, `MIN`.

#### ➕ 4. DML, TCL, DDL

| 구분 | 명령어 | 특징 |
| :--- | :--- | :--- |
| **DML** (조작어) | `INSERT`, `UPDATE`, `DELETE` | 데이터 조작. **`ROLLBACK` 가능**. |
| **TCL** (제어어) | `COMMIT`, `ROLLBACK` | DML로 인한 변경을 영구 저장하거나 취소. |
| **DDL** (정의어) | `CREATE`, `ALTER`, `DROP`, `TRUNCATE` | 객체 구조 정의. **자동 COMMIT**되어 `ROLLBACK` 불가. |

*   **`DELETE` vs `TRUNCATE`**: `DELETE`는 행 단위 삭제로 느리고 `ROLLBACK` 가능. `TRUNCATE`는 테이블 전체 삭제로 빠르고 `ROLLBACK` 불가.

#### ➕ 5. 제약조건 (Constraints)

*   데이터의 **무결성**을 보장하기 위한 규칙.
    *   **`PRIMARY KEY`**: 유일성과 `NOT NULL`을 보장하는 대표 키.
    *   **`FOREIGN KEY`**: 테이블 간의 관계를 정의 (참조 무결성).
    *   **`UNIQUE`**: 유일성을 보장 (`NULL` 허용).
    *   **`NOT NULL`**: `NULL` 값 입력을 방지.
    *   **`CHECK`**: 값의 범위나 조건을 제한.

---

### 📌 최종 요약

*   **1과목(모델링)**은 데이터베이스의 **뼈대(설계)**를 만드는 과정으로, **정규화**를 통해 데이터의 **무결성**을 확보하는 것이 핵심입니다.
*   **2과목(SQL)**은 설계된 뼈대를 **활용(조작)**하는 기술로, **논리적 실행 순서**에 대한 이해를 바탕으로 **`JOIN`**과 **서브쿼리**를 사용하는 것이 핵심입니다.
*   궁극적으로 SQLD는 **무결성이 높은 데이터 모델**을 설계하고, 이를 **효율적인 SQL**로 활용할 수 있는 능력을 평가하는 시험입니다.