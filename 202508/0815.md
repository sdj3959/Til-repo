## 0815 데이터베이스 모델링과 QueryDSL 동적 쿼리

---

### ✅ 1. 데이터 모델링의 핵심 요소 (SQLD)

*   데이터 모델링은 현실 세계의 업무를 추상화하여 데이터베이스 구조로 설계하는 과정으로, **개념적, 논리적, 물리적** 3단계로 진행됩니다.

#### ➕ 주요 구성 요소

1.  **엔터티 (Entity)**: 관리해야 할 데이터의 대상(테이블). **식별자**에 의해 유일하게 구분되며, 2개 이상의 **인스턴스**(행)와 **속성**(컬럼)을 가집니다.
2.  **속성 (Attribute)**: 엔터티를 설명하는 최소 데이터 단위(컬럼). 다른 속성에서 계산되는 **파생 속성**이나 여러 값을 가질 수 있는 **다중값 속성** 등은 설계 시 주의가 필요합니다.
3.  **관계 (Relationship)**: 엔터티 간의 논리적 연관성. **관계 차수(1:1, 1:N, M:N)**와 **관계 선택성(필수/선택)**으로 표현됩니다. M:N 관계는 관계형 DB에서 직접 표현이 불가하여, 별도의 **관계 엔터티**로 해소해야 합니다.
4.  **식별자 (Identifier)**: 각 인스턴스를 유일하게 구분하는 속성(PK). **유일성, 최소성, 불변성, 존재성**을 만족해야 합니다. 부모의 식별자를 자식이 자신의 PK로 사용하면 **식별 관계**, 일반 속성으로 사용하면 **비식별 관계**가 됩니다.

---

### ✅ 2. 여행 관리 기능 데이터 모델링

*   위의 데이터 모델링 원칙에 따라 여행 관리 기능의 핵심 엔터티인 **`Trip`**과 상태를 나타내는 **`TripStatus` Enum**을 설계했습니다.

*   **`Trip` 엔터티**: 여행의 제목, 기간, 예산 등 핵심 정보를 관리하며, `User` 엔터티와 **다대일(N:1) 관계**를 맺습니다.
*   **`TripRepository`**: `JpaRepository`를 상속받아 `Trip` 데이터의 기본적인 CRUD 연산을 담당합니다.

---

### ✅ 3. QueryDSL을 활용한 동적 검색 기능

*   사용자의 다양한 검색 조건(여행 상태, 목적지 등)과 정렬 기준에 따라 여행 목록을 조회할 수 있도록 **QueryDSL**을 도입하여 동적 쿼리 기능을 구현했습니다.

#### ➕ 구현 절차

1.  **설정**: `build.gradle`에 QueryDSL 의존성을 추가하고, `JPAQueryFactory`를 Bean으로 등록했습니다.
2.  **커스텀 Repository 분리**:
    *   `TripRepositoryCustom` 인터페이스에 동적 쿼리 메서드를 선언합니다.
    *   `TripRepositoryImpl` 구현체에서 `JPAQueryFactory`를 사용하여 실제 동적 쿼리 로직을 작성합니다.
3.  **동적 쿼리 로직**:
    *   **`TripSearchCondition` DTO**: 클라이언트의 검색 조건을 담는 객체입니다.
    *   **`where()` 다중 파라미터**: `TripSearchCondition`의 필드 값이 존재할 경우에만 `where` 절에 해당 조건을 추가하여 동적으로 쿼리를 생성합니다.
    *   **`orderBy()`와 `OrderSpecifier`**: 검색 조건에 포함된 정렬 기준에 따라 정렬 순서를 동적으로 변경합니다.

---

### 📌 요약

*   데이터 모델링의 핵심 개념인 **엔터티, 속성, 관계, 식별자**를 학습하고, 이를 바탕으로 **여행(Trip) 엔터티**를 설계했습니다.
*   **QueryDSL**을 도입하여, 사용자의 다양한 검색 조건과 정렬 기준에 유연하게 대응할 수 있는 **동적 쿼리** 기능을 구현했습니다.
*   Repository의 역할을 기본 CRUD와 복잡한 동적 쿼리로 분리하여 코드의 **유지보수성과 확장성**을 높였습니다.