## 1224 클라우드 네이티브 기술 복습: Docker와 Kubernetes

---

### ✅ 1. Docker: 애플리케이션의 표준화된 포장지

*   **도커(Docker)**는 애플리케이션과 그 실행에 필요한 모든 환경(코드, 런타임, 라이브러리, 설정 파일 등)을 **"컨테이너(Container)"**라는 격리된 표준 단위로 패키징하는 기술입니다.

*   **핵심 역할**: **"빌드하고, 배송하고, 어디서든 실행한다(Build, Ship, and Run Any App, Anywhere)"**
    *   **이식성 (Portability)**: 컨테이너는 OS나 기본 인프라에 상관없이 어디서든 동일하게 동작합니다. "제 컴퓨터에서는 되는데, 서버에서는 안 돼요" 문제를 근본적으로 해결합니다.
    *   **격리 (Isolation)**: 각 컨테이너는 독립된 파일 시스템, 네트워크, 프로세스 공간을 가집니다. 이를 통해 하나의 서버에서 여러 애플리케이션을 서로의 영향 없이 안정적으로 실행할 수 있습니다.

#### ➕ Docker의 기본 구성 요소 복습

1.  **`Dockerfile`**:
    *   나만의 커스텀 **이미지**를 만들기 위한 **설계도(Recipe)**.
    *   베이스 이미지 선택(`FROM`), 파일 복사(`COPY`), 명령어 실행(`RUN`, `CMD`) 등을 순서대로 정의하는 텍스트 파일입니다.

2.  **이미지 (Image)**:
    *   컨테이너를 생성하기 위한 **읽기 전용(Read-Only) 템플릿**.
    *   애플리케이션과 그 실행 환경의 스냅샷입니다.

3.  **컨테이너 (Container)**:
    *   이미지를 기반으로 **실행된 인스턴스**.
    *   실제 애플리케이션이 동작하는 격리된 프로세스입니다.

4.  **레지스트리 (Registry)**:
    *   Docker 이미지를 저장하고 공유하는 **중앙 저장소**. (e.g., **Docker Hub**, **AWS ECR**)

---

### ✅ 2. Kubernetes: 컨테이너 오케스트레이션의 표준

*   **문제점**: 도커만으로는 수십, 수백 개의 컨테이너를 운영 환경에서 안정적으로 관리하기 어렵습니다. (장애 복구, 스케일링, 네트워킹, 배포 자동화 등)

*   **쿠버네티스(Kubernetes, k8s)**는 이러한 복잡한 문제들을 해결하기 위한 **컨테이너 오케스트레이션(Container Orchestration)** 플랫폼입니다. 즉, **"컨테이너 군단(Fleet)을 지휘하는 지휘관"** 역할을 합니다.

#### ➕ Kubernetes의 핵심 역할 (자동화)

1.  **스케줄링 (Scheduling)**: 컨테이너를 어떤 서버(노드)에 배치할지 리소스 상황을 고려하여 자동으로 결정합니다.
2.  **자동 복구 (Self-healing)**: 컨테이너나 노드에 장애가 발생하면, 이를 감지하고 자동으로 컨테이너를 재시작하거나 다른 노드로 옮겨서 서비스의 가용성을 유지합니다.
3.  **오토 스케일링 (Auto-scaling)**: CPU 사용량과 같은 지표에 따라 컨테이너의 수를 자동으로 늘리거나 줄여 트래픽 변화에 탄력적으로 대응합니다.
4.  **서비스 디스커버리 및 로드 밸런싱**: 수시로 생성되고 사라지는 컨테이너들에게 안정적인 네트워크 주소를 제공하고, 요청을 여러 컨테이너에 자동으로 분산합니다.
5.  **무중단 배포 및 롤백**: 서비스 중단 없이 애플리케이션을 새로운 버전으로 업데이트(롤링 업데이트)하고, 문제가 발생하면 이전 버전으로 쉽게 되돌릴(롤백) 수 있습니다.

#### ➕ Kubernetes 핵심 오브젝트 복습

| 오브젝트 | 역할 | 비유 |
| :--- | :--- | :--- |
| **Pod** | • 컨테이너를 감싸는 가장 작은 배포 단위.<br>• 일회성이며 IP가 계속 바뀜. | 컨테이너를 담는 작은 캡슐 |
| **Deployment** | • Pod의 개수와 버전을 관리.<br>• **자동 복구, 스케일링, 무중단 업데이트**를 책임짐. | Pod를 관리하는 현장 매니저 |
| **Service** | • 변하기 쉬운 Pod들에게 **고정된 IP와 DNS 이름**을 부여.<br>• 요청을 여러 Pod에 **로드 밸런싱**. | Pod 그룹의 대표 전화번호, 안내 데스크 |
| **ConfigMap / Secret** | • 애플리케이션의 **설정/비밀 정보**를 코드와 분리하여 관리. | 설정 파일 보관함 / 비밀 금고 |

---

### ✅ 3. Docker와 Kubernetes의 관계

*   **Docker**와 **Kubernetes**는 경쟁 관계가 아닌, **상호 보완적인 관계**입니다.

*   **Docker**는 컨테이너를 **만들고(Build), 실행하는(Run)** 저수준의 **"컨테이너 엔진"** 기술에 집중합니다. (컨테이너라는 표준화된 화물을 만듦)
*   **Kubernetes**는 Docker로 만들어진 수많은 컨테이너들을 **대규모 환경에서 조율하고 관리하는(Orchestrate)** 고수준의 **"관리 플랫폼"**입니다. (수많은 화물들을 배송하고, 관리하고, 배치하는 물류 시스템)

*   **흐름**:
    1.  개발자는 **Dockerfile**을 사용하여 애플리케이션을 **Docker 이미지**로 만듭니다.
    2.  이 이미지를 **Docker Hub**나 **ECR**과 같은 레지스트리에 푸시합니다.
    3.  운영자는 **Kubernetes**의 **Deployment** YAML 파일에 사용할 이미지의 주소를 명시합니다.
    4.  Kubernetes는 레지스트리에서 해당 이미지를 가져와 **Pod** 내부에서 **컨테이너**로 실행하고, **Service**를 통해 외부에 노출시킵니다.

---

### 📌 요약

*   **Docker**는 애플리케이션을 **"어떻게 포장할 것인가"**에 대한 해답을 제공하며, **이식성과 격리성**을 보장합니다.
*   **Kubernetes**는 포장된 수많은 컨테이너들을 **"어떻게 대규모로 운영하고 관리할 것인가"**에 대한 해답을 제공하며, **자동화, 안정성, 확장성**을 보장합니다.
*   **클라우드 네이티브** 환경에서, **Docker**로 애플리케이션을 표준화하고 **Kubernetes**로 이를 오케스트레이션하는 것은 마이크로서비스 아키텍처를 성공적으로 운영하기 위한 사실상의 표준입니다.